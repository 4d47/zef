=pod

=encoding utf8

=head2 Name

Zef - Perl6 Module Management

=for HTML <a href="https://travis-ci.org/ugexe/zef"><img src="https://travis-ci.org/ugexe/zef.svg?branch=master"></a>

=head1 USAGE

=head1 The CLI

    zef -v install CSV::Parser
    # duh

    zef -v uninstall CSV::Parser
    # noooooo!

    zef -v --report install CSV::Parser
    # fire off test reports this time *onomatopoeia of an uzi*

    zef -v search CSV::Parser
    # search for module names matching `CSV::Parser`

    zef -v build
    # build project in current directory
    
    zef -v test
    # test project in current directory

=head2 More CLI

=head4 install

Fetch, build, test, optional report, and install.

    # verbose output
    # -v

    # send a test report
    # --report

    # parallel testing # todo: parallel build/install
    # --async

    # no status bar or other CLI eye candy
    --boring

    # do everything except the actually install
    --dry

    # run the tests in a random order instead of sorted
    --shuffle

    # skip modules with matching names (or any modules depending on them)
    --ignore=Acme::Virus --ignore=Acme::TakesForever

    # livin that multi thread life
    zef -v --report --async install HTTP::Server::Threaded

=head4 smoke

Tests every module in the ecosystem, ignoring any modules with a name (or dependency name) matching argument C<*@ignores>

    snoop@cali:~/ perl6 -Ilib bin/zef -v --report smoke

    # skip modules with matching names (or any modules depending on them)
    --ignore=Acme::Virus --ignore=Acme::TakesForever

    # same as install options
    --boring
    --smoke
    --dry
    -v

=head4 search

Take C<*%args> filters. That is, any C<--[field]="term"> passed will search for "term" in it's META [field].

Add a C<*> to any filter to have the filter apply a C<.starts-with()> filter using the string to the left of the C<*>.

Note: C<*> behaves slightly differently for C<--version>

    # search by name
    zef -v search Text::Table::Simple            # or zef -v --name="Text::Table::Simple"

    # search by version
    zef -v --version="*" search                  # Version filter only
    zef -v --version="*" search HTTP::Server     # Can search for 'whatevers'
    zef -v --version="0.1" search HTTP::Server   # Version matching
    zef -v --version="0.1+" search HTTP::Server  # Basic version ranges

    # search by other fields in META
    zef -v --depends="HTTP::Server" search       # Match `HTTP::Server` inside --`depends`

    # a naive substring search using a wildcard
    zef -v --depends="HTTP*" search              # Matches anything that $results.starts-with("HTTP")

    # sure
    zef -v --depends="HTTP::Server" --version="0.1+" search HTTP::Server::Threaded
    
=head4 info

Given C<*@modules> it will list a formatted version of each's `META.info` data.

    # -v to also list `provides` section
    zef -v info JSON::Tiny

=head1 INCLUDED TOOLS

=head2 Zef::Net::HTTP

HTTP library interfaces and Grammars.

    use Zef::Net::HTTP::Client;
    
    my $client = Zef::Net::HTTP::Client.new(:auto-check);

    my $body     = to-json({ term => "zef" });
    my $response = $client.post("http://httpbin.org/post", :$body);

    # .content takes care of encoding. The .body attribute has the raw data for manual processing
    my $json     = from-json($response.content);

    my $response = $client.get("https://www.google.com");
    say $reponse.content; # returns $.body with encoding/chunked/etc applied

or build your own client by satisfying the interface requirements during object construction:

    use Zef::Net::HTTP::Client;

    use Different::Responder;
    use Different::Requestor;
    use You::Get::The::Idea;

    Zef::Net::HTTP::Client.new(              # Zef::Net::HTTP interface type
        responder   => Different::Responder, # HTTP::Response
        requestor   => Different::Requestor, # HTTP::Request
        transporter => You::Get::The::Idea   # HTTP::Transport
    );

=head1 NOTES

=head2 Links

L<Zef.pm|https://zef.pm/>

L<http://modules.perl6.org/>

=head2 Full Flex

 * ✓ No external dependencies
 * ✓ CompUnitRepo::Local based
 * ✓ Test reporting to P6C servers
 * Test reporting to Zef servers
 * Rotating OS smoke testing server integration
 * ✓ Use perl6 github ecosystem as an additional authority
 * ✓ HTTP library
 * HPACK/HTTP2 compatability
 * ✓ Parallelized testing
 * TAP Harness/Grammar
 * Parallelized building
 * ✓ Basic CLI overlay/hud
 * Pure Perl6 decompression/git-clone library

=cut
